from os import getuid
import gobject
from input_header import input_header

if getuid() != 0:
  raise ImportError, "Must be root to get keypresses."

from struct import unpack

# Code 0 = Mouse x axis, val = mouse accel (with +/-)
# Code 1 = Mouse y axis, val = mouse accel (with +/-)

KEY_PRESS = 1
KEY_RELEASE = 2

class keyevent(object):
  def __init__(self, t_sec, t_usec, typ, code, val):
    self.ih = input_header()
    self.seconds = t_sec
    self.microseconds = t_usec
    self.type = typ
    self.code = code
    self.value = val

  def __str__(self):
    return "[%s.%s] type %s, code %s, value %s" % (self.seconds,
                            self.microseconds, self.type, self.code, self.value)

class reader(gobject.GObject):
  DEFAULT_EVENT_PATH = "/dev/input/event4"

  __gsignals__ = {
    "mouse_abs": (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE,
                  (gobject.TYPE_PYOBJECT, )),
    "mouse_rel": (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE,
                  (gobject.TYPE_PYOBJECT, )),

    "key_down": (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE,
                  (gobject.TYPE_PYOBJECT, )),
    "key_up": (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE,
                  (gobject.TYPE_PYOBJECT, )),

    "all": (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE,
                  (gobject.TYPE_PYOBJECT, )),
  }

  def __init__(self, eventpath = DEFAULT_EVENT_PATH, keywatches = None):
    gobject.GObject.__init__(self)
    self.eventpath = eventpath
    self.trap_repeats = False
    self.port = open(self.eventpath,"rb")

  def trap_repeat(self, on):
    self.trap_repeats = on

  def emit_events(self, ev):
    if ev.type == ih.EV_ABS:
      if ev.code == ih.ABS_X:
        self.emit("mouse_abs", (ev.value, 0))
      elif ev.code == ih.ABS_Y:
        self.emit("mouse_abs", (0, ev.value))
    elif ev.type == ih.EV_REL:
      if ev.code == ih.REL_X:
        self.emit("mouse_rel", (ev.value, 0))
      elif ev.code == ih.REL_Y:
        self.emit("mouse_rel", (0, ev.value))
    elif ev.type == ih.EV_KEY:
      if ev.value == 0:
        self.emit("key_up", ev)
      elif ev.value == 1:
        self.emit("key_down", ev)
      elif ev.value == 2 and self.trap_repeats:
        self.emit("key_down", ev)
    self.emit("all", ev)

  def readkeyevent(self, emit = False):
    ev = keyevent(*unpack("2I2Hi",self.port.read(16)))
    if emit:
      self.emit_events(ev)
    return ev

  def readkey(self):
    while True:
      code, val = self.readkeyevent()
      if val > 0:
        #lockcode = code
        #while True:
        #  code, val = self.readkeyevent()
        #  if code == lockcode and val != 1: # returns on key-release or key-hold
        #    return code

        # 0 is generated by a repeat keypress
        if code == 0:
          return self.last_key
        else:
          self.last_key = code
          return code

  def run(self):
    while 1:
      self.readkeyevent(True)

if __name__ == "__main__":
  gobject.threads_init()
  from input_header import input_header
  ih = input_header()
  r = reader("/dev/input/event9")
  def print_event(obj, ev):
    print ev
  r.connect("key_down", print_event)
  r.trap_repeat(True)
  r.run()
